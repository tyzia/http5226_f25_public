




Plan




Why View?
UI
Data for the View
Static View
Dynamic View
ViewBag
Problems with ViewBag
View Model


















Why View?



Developers spend a lot of time focusing on
well-factored controllers & model objects.

And for good reason - clean, well-written
code forms the basis of a maintainable web app.




But when users visit web app, none of that
work is visible.

A user's first impression and entire interaction
with you app starts with the View.




Obviously, if the rest of app is buggy,
no matter how good your view is, this will
not make up.

Likewise, build an ugly and hard-to-use view,
and many users will not give your app a
chance even if it is feature rich and bug-free.







Today I am not going to teach you how to
make a pretty view. It is job of a designer.

I will demonstrate how views work and how
to create clean markup.





Last lesson we learned about controllers
and how they can return a string.

Example

public string Browse()
{
    return "Hello from Browse()";
}




In real-world apps, you would notice
a pattern: most controller actions
need to display dynamic content
in HTML format.

That's when View comes into play.



UI


The view is responsible for providing
User Interface (UI) to the user.

After the controller has executed
the appropriate logic for the requested URL,
it delegates the display to the view.




Direct access to a View


Views are not directly accessible.
You can't point your browser to a view
and have it render.

Instead, a view is always rendered by
a controller.




Data for the View



In some cases view needs little or no
information from the controller.

More often the controller needs to
provide some information to the view,
it passes a data transfer object (DTO)
called a model.


The view transforms that model into a
format ready to be presented to the user.




View code



Views are special files by convention
saved under /Views/ folder.

These are Razor files (.cshtml) that
contain a mix of HTML markup and C# code.


Let's start by looking at a view generated by:
> dotnet new mvc MyApp

demo/MyApp/Views/Home/Index.cshtml

Example

@{
    ViewData["Title"] = "Home Page";
}

<div class="text-center">
    <h1 class="display-4">Welcome</h1>
    <p>Learn about <a href="url">building Web apps</a>.</p>
</div>


Here:

Apart from first lines of code (set page title),
the rest is plain HTML.




Static View




Let's come back to /Controllers for a moment.
We have /Controllers/HomeController.cs
and Index() method:

public IActionResult Index()
{
    return View();
}


So browsing to the root of the website
will invoke /Controllers/HomeController.cs
and Index() method, which will return
a View from /Views/Home/Index.cshtml file.


Or steps:

1) Browser requests: "/"
2) /Controllers/HomeController.cs
3) Index()
4) /Views/Home/Index.cshtml
5) Browser renders a page.



It is a very basic example.
It renders static HTML, meaning,
it is always the same.



How do we display a variable info
on the page (View)?

Ex. User name or current time






Dynamic View


Now let's try to make it dynamic,
so that view works as a real template.

For this task we need to pass some
data from controller to a view.



There are some ways to pass data:

1. ViewBag
2. View Model








ViewBag


The easiest way to do that is
using ViewBag.

ViewBag is a dynamic object.
You can assign any property to it on the fly.


Example

Add action method to Home controller:

public IActionResult About()
{
    ViewBag.Message = "About my awesome app";
    ViewBag.FoundedYear = 2025;
    return View();
}

Add About view:

/Views/Home/About.cshtml

@{
    ViewBag.Title = "About Page";
}

<h2>@ViewBag.Title</h2>
<h3>@ViewBag.Message</h3>
<p>Founded in: @ViewBag.FoundedYear</p>

Here:

I use ViewBag to display dynamic content
on the page.

<h3>@ViewBag.Message</h3>

@ is the most important in this syntax,
it tells Razor engine to treat next
characters as code, and not as html.



Now check that it works.

> dotnet run

go to http://localhost:5235/Home/About


If I want to change the text,
I will change the controller to:

ViewBag.Message = "About my normal app";

Reloading the app in the browser still shows:

"About my awesome app"

and not the new:

"About my normal app"

Why?









Answer:
We need to recompile or rebuild our app again,
once we make a change in the code.

To do so:

Stop the app: CTRL + C
Make and save the changes in code.
Run it again: > dotnet run




The problem with ViewBag



Suppose I need a view to display a list
of Album instances.

One possible approach is to simply
add the albums to the ViewBag,
iterate over them and display.

Example

controller:
public ActionResult List()
{
    List<Album> albums = new List<Album>();
    for (int i = 0; i < 10; i++) {
        albums.Add(new Album { Title = "Album " + i });
    }
    ViewBag.Albums = albums; // add to ViewBag
    return View();
}

To use this ViewBag in the View you
CAN'T do this:

Doesn't work!

<ul>
    @foreach (Album album in ViewBag.Albums) {
        <li>@album.Title</li>
    }
</ul>

The problem

ViewBag is dynamically typed.
This means that ViewBag.Albums can
be any type. MVC defaults it to object.

The compiler sees:

1) ViewBag.Albums â†’ type = object
2) foreach needs IEnumerable type
3) object doesn't guarantee it's enumerable

As a result @foreach doesn't work.

You need to cast ViewBag.Albums to enumerable:

This works!

<ul>
    @foreach (Album album in (ViewBag.Albums as IEnumerable<Album>)) {
        <li>@album.Title</li>
    }
</ul>

Result:

<ul>
    <li>Album 0</li>
    <li>Album 1</li>
    ...
    <li>Album 9</li>
</ul>




Other problems with ViewBag.


- No compilation errors for ViewBag.

If instead of "ViewBag.Albums"
you mistype:

ViewBag.Alums // missing "b"

You get an empty value, not a compiler error.

This is a maintenance nightmare.


- ViewBag doesn't scale.

For complex data with multiple properties,
ViewBag becomes messy.


Conclusion:
ViewBag is fine for small,
simple pieces of data.





Strongly Typed Views


To get the benefit of type
we can pass a data from controller
to a view and use @model to
tell the view how to interpret that data.

We are not passing specifically a Model
here, just a data.


Example

model:
public class Album { ... }

controller:
public ActionResult List()
{
    List<Album> albums = new List<Album>();
    for (int i = 0; i < 10; i++) {
        albums.Add(new Album { Title = "Album " + i });
    }

    // albums
    [
     { Title: "Album 0" },
     { Title: "Album 1" },
     ...
     { Title: "Album 9" },
    ]

    return View(albums); // Pass data to the view
}




view:
@model IEnumerable<MyProject.Models.Album>
<ul>
    @foreach (Album album in Model) { <<<< notice Model
        <li>@album.Title</li>
    }
</ul>


Here

@foreach (Album album in Model) { ... }

we use Model in the loop of the view.
This property is available by default
and it has our 'albums' passed from
controller.

But this Model still doesn't "know"
the type of the data ('albums').

To specify the type we add:

@model IEnumerable<MyProject.Models.Album>


Here we use IEnumerable, but not something:

@model List<MyProject.Models.Album>

Because we want to make our view flexible.

IEnumerable is a general type for any
collection (accepts List<T>, Array<T>,
Collection<T>) and if in the future I'd
change controller code to pass
not a List of Albums, but Array of Albums,
I'd not need to change my view code.




To avoid fully qualified name (starting from project root)
we can use "using":

@using MyProject.Models
@model IEnumerable<Album>
<ul>
    @foreach (Album album in Model) {
        <li>@album.Title</li>
    }
</ul>






View Model


The above approach is better than ViewBag,
but still not perfect.

Often view needs to display a variety
of data that doesn't map directly to
a Model.


Example

View to display details of a product
and user information who purchased it.

The problem:

- You have model for Product
- You have model for User
- How to combine two models in one view?

Very bad decision:

- To add User properties into Product model class.

Example

public class Product
{
    // Adding view-specific concerns - WRONG!
    public string PageTitle { get; set; }
    public User CurrentUser { get; set; }
}


Other way to solve:

- Choose your main model for a view (let's say Product)
- Add extra information via ViewBag.


Example

controller:
public ActionResult List()
{
    List<Album> albums = new List<Album>();
    for (int i = 0; i < 10; i++) {
        albums.Add(new Album { Title = "Album " + i });
    }
    ViewBag.PageTitle = "My Albums"; // Extra data
    ViewBag.CurrentUser = "admin"; // Extra data (from User Model)

    return View(albums); // Main data
}

view:
@using MyProject.Models
@model IEnumerable<Album>

<h1>@ViewBag.PageTitle</h1> <<<<< Weakly typed
<h2>user: @ViewBag.CurrentUser</h2> <<<<< Weakly typed
<ul>
    @foreach (Album album in Model) {
        <li>@album.Title</li>
    }
</ul>




ViewModel


So the correct solution is a special Model
for view - ViewModel.

This is a specific Model designed to work
with specific View.

It combines data from multiple domain models
and additional view-specific properties
into a single object.



Example

viewModel:

/Models/ViewModels/AlbumListViewModel.cs

namespace MyApp.Models.ViewModels
{
    public class AlbumListViewModel
    {
        public IEnumerable<Album> Albums { get; set; }
        public string PageTitle { get; set; }
        public string CurrentUser { get; set; }
    }
}


controller:

using MyApp.Models.ViewModels;

public ActionResult List()
{
    List<Album> albums = new List<Album>();
    for (int i = 0; i < 10; i++) {
        albums.Add(new Album { Title = "Album " + i });
    }

    AlbumListViewModel viewModel = new AlbumListViewModel
    {
        Albums = albums,
        PageTitle = "My Albums",
        CurrentUser = "admin"
    };

    return View(viewModel); // everything in one strongly-typed package
}


view:

@using MyProject.Models.ViewModel
@model AlbumListViewModel

<h1>@Model.PageTitle</h1>
<h2>user: @Model.CurrentUser</h2>
<ul>
    @foreach (Album album in Model.Albums) {
        <li>@album.Title</li>
    }
</ul>










To sum up the progress:


ViewBag ->>> Model ->>> Model + ViewBag ->>> ViewModel



1) ViewBag

// Controller
ViewBag.Albums = albums;

// View
@foreach (Album album in (ViewBag.Albums as IEnumerable<Album>)) {
    <li>@album.Title</li>
}

Problems:
Needs casting, no type safety.


2) Model (Better but Limited)

// Controller
return View(albums); // type List<Album>

// View
@model IEnumerable<MyProject.Models.Album>
<ul>
    @foreach (Album album in Model) {
        <li>@album.Title</li>
    }
</ul>

Problems:
Only one object is passed.
How to pass extra info?


3) Enlarge Domain Model (very bad)

// Model
public class Product
{
    ...
    public string PageTitle { get; set; }
    public string CurrentUser { get; set; }
}

Problems:
Adding unrelated info to Model.



4) Model + ViewBag (not recommended)

// Controller
return View(albums); // Main data
ViewBag.PageTitle = "My Albums"; // Extra data

// View
@model IEnumerable<Album>
<h1>@ViewBag.PageTitle</h1>


Problems:
Mixing approaches. Limited type safety.


5) ViewModel (recommended!)

// ViewModel
public class AlbumListViewModel
{
    public IEnumerable<Album> Albums { get; set; }
    public string PageTitle { get; set; }
    public string CurrentUser { get; set; }
}

// Controller
return View(viewModel);

// View
@model AlbumListViewModel
<h1>@Model.PageTitle</h1>
Welcome, @Model.CurrentUser.Name!

Benefits:
Type-safe, compiler-checked, great IntelliSense,
self-documenting.














Let's apply what we have learned.



Our task:

Our app should display a list of albums
with welcome message and user info
on the same page.


Technical implementation:

1. Create new Controller for /Albums/List url.
2. Create new Model Album.
3. Create new ViewModel for List view.
4. Create new List view.
5. "Glue" them together.


Explanation:

1. User loads url /Albums/List
2. This URL is mapped to Controllers/AlbumsController.cs
3. Inside of controller there is a method List() which
uses ViewModel class to pass data to view.
4. For that we need to create ViewModel + View.



Step-by-step


> cd lecture/demo/LecDemo

You need to be inside of project folder
and run all commands from there.


1) Create new Controller

> dotnet new mvccontroller -n AlbumsController -o Controllers

For now, we are leaving it and
move to create Models & Views
which we need.


2) Create new Model

> dotnet new class -n Album -o Models

Update the code:

namespace LecDemo.Models;

public class Album
{
    public string Title { get; set; }
}




3) Create new ViewModel

> dotnet new class -n AlbumListViewModel -o Models/ViewModels

Open /Models/ViewModels/AlbumLIstViewModel.cs and add:

using LecDemo.Models;
namespace LecDemo.Models.ViewModels;

public class AlbumListViewModel
{
    public IEnumerable<Album> Albums { get; set; }
    public string PageTitle { get; set; }
    public string CurrentUser { get; set; }
}


4) Update controller

Let's get back to the controller
we created at step #1 and update it.

4.1 Change namespace to:

namespace LecDemo.Controllers

4.2. Change method return type for Index():

public IActionResult Index()


Add code to controller class:

using LecDemo.Models.ViewModels;
using LecDemo.Models;

public IActionResult List()
{
    List<Album> albums = new List<Album>();
    for (int i = 0; i < 10; i++) {
        albums.Add(new Album { Title = "Album " + i });
    }

    AlbumListViewModel viewModel = new AlbumListViewModel
    {
        Albums = albums,
        PageTitle = "My Albums",
        CurrentUser = "admin"
    };

    return View(viewModel);
}


5) Create View


> dotnet new view -n List -o Views/Albums

Add code to it:

@using LecDemo.Models.ViewModels
@model AlbumListViewModel

<h1>@Model.PageTitle</h1>
<div class="user-info">
    <h2>Welcome, @Model.CurrentUser!</h2>
</div>

<ul>
    @foreach (Album album in Model.Albums)
    {
        <li>@album.Title</li>
    }
</ul>



6) Build the app

> dotnet run


7) See the result

http://localhost:5235/Albums/List







Pay attention!

URL is designed to have /Albums (plural)
Controller name must be AlbumsController.cs (plural)
View files must be in /Views/Albums/* (plural)












To fix the warnings:

warning CS8618: Non-nullable property 'Albums'
must contain a non-null value when exiting
constructor. Consider adding the 'required'
modifier or declaring the property as nullable.


Add ? to all our types:

// viewModel

public class AlbumListViewModel
{
    public IEnumerable<Album>? Albums { get; set; }
    public string? PageTitle { get; set; }
    public string? CurrentUser { get; set; }
}

// model

public class Album
{
    public string? Title { get; set; }
}

Another warning:

warning CS8602: Dereference of a possibly null reference.

That means that instead of adding '?' to fix
previous warning, a better way to fix it:

public IEnumerable<Album> Albums { get; set; } = new List<Album>();




This warning actually points out
to a potential issue - what should
we display if there is no albums?


Best practice would be to
check Albums for null and display
some text in case it is true.


Example

@if (Model.Albums != null)
{
    <ul>
        @foreach (Album album in Model.Albums)
        {
            <li>@album.Title</li>
        }
    </ul>
}
else
{
    <p class="text-muted">No albums found.</p>
}














Hints for the lab:

1)

To filter Products by Price in the list:

// you have list of 'products'
// you have 'price' which you use as filter value

IEnumerable<Product> filteredProducts =
    products.Where(product => product.Price == price);


2)

To check if something is null:

string.IsNullOrEmpty(possiblyEmpty) ? "empty case" : "non-empty case"












Thank you!